"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkForge = exports.checkCast = exports.checkAnvil = exports.checkFoundryUp = exports.run = exports.selfInstall = exports.foundryForgeBinPath = exports.foundryCastBinPath = exports.foundryAnvilBinPath = exports.foundryBinDir = exports.foundryDir = exports.getForgeCommandSync = exports.getForgeCommand = exports.getCastCommand = exports.getAnvilCommand = void 0;
const child_process_1 = require("child_process");
const os = require("os");
const path = require("path");
const commandExists = require("command-exists");
const FOUNDRYUP_INSTALLER = 'curl -sSL "https://foundry.paradigm.xyz" | sh';
/**
 * @returns the path to the anvil path to use, if `anvil` is in path then this will be returned
 *
 */
async function getAnvilCommand() {
    try {
        return commandExists("anvil");
    }
    catch (e) {
        const cmd = foundryAnvilBinPath();
        await checkCommand(`${cmd} --version`);
        return cmd;
    }
}
exports.getAnvilCommand = getAnvilCommand;
/**
 * @returns the path to the cast path to use, if `cast` is in path then this will be returned
 *
 */
async function getCastCommand() {
    try {
        return commandExists("cast");
    }
    catch (e) {
        const cmd = foundryCastBinPath();
        await checkCommand(`${cmd} --version`);
        return cmd;
    }
}
exports.getCastCommand = getCastCommand;
/**
 * @returns the path to the forge path to use, if `forge` is in path then this will be returned
 *
 */
async function getForgeCommand() {
    try {
        return commandExists("forge");
    }
    catch (e) {
        const cmd = foundryForgeBinPath();
        await checkCommand(`${cmd} --version`);
        return cmd;
    }
}
exports.getForgeCommand = getForgeCommand;
/**
 * @returns the path to the forge path to use, if `forge` is in path then this will be returned
 *
 */
function getForgeCommandSync() {
    if (commandExists.sync("forge")) {
        return "forge";
    }
    else {
        const cmd = foundryForgeBinPath();
        checkCommandSync(`${cmd} --version`);
        return cmd;
    }
}
exports.getForgeCommandSync = getForgeCommandSync;
/**
 * @returns the path to the foundry directory: `$HOME/.foundry`
 */
function foundryDir() {
    return path.join(os.homedir(), ".foundry");
}
exports.foundryDir = foundryDir;
/**
 * @returns the path to the foundry directory that stores the tool binaries: `$HOME/.foundry/bin`
 */
function foundryBinDir() {
    return path.join(foundryDir(), "bin");
}
exports.foundryBinDir = foundryBinDir;
/**
 * @returns the path to the anvil binary in the foundry dir: `$HOME/.foundry/bin/anvil`
 */
function foundryAnvilBinPath() {
    return path.join(foundryDir(), "anvil");
}
exports.foundryAnvilBinPath = foundryAnvilBinPath;
/**
 * @returns the path to the cast binary in the foundry dir: `$HOME/.foundry/bin/cast`
 */
function foundryCastBinPath() {
    return path.join(foundryDir(), "cast");
}
exports.foundryCastBinPath = foundryCastBinPath;
/**
 * @returns the path to the anvil forge in the foundry dir: `$HOME/.foundry/bin/forge`
 */
function foundryForgeBinPath() {
    return path.join(foundryDir(), "forge");
}
exports.foundryForgeBinPath = foundryForgeBinPath;
/**
 * Installs foundryup via subprocess
 */
async function selfInstall() {
    return new Promise((resolve) => {
        const process = (0, child_process_1.spawn)("/bin/sh", ["-c", FOUNDRYUP_INSTALLER], {
            stdio: "inherit",
        });
        process.on("exit", (code) => {
            resolve(code === 0);
        });
    });
}
exports.selfInstall = selfInstall;
/**
 * Executes `foundryup`
 *
 * @param install whether to install `foundryup` itself
 * @param _target additional `foundryup` params
 */
async function run(install = true, _target = {}) {
    if (install) {
        if (!(await checkFoundryUp())) {
            if (!(await selfInstall())) {
                return false;
            }
        }
    }
    return checkCommand("foundryup");
}
exports.run = run;
/**
 * Checks if foundryup exists
 *
 * @return true if `foundryup` exists
 */
async function checkFoundryUp() {
    return checkCommand("foundryup --version");
}
exports.checkFoundryUp = checkFoundryUp;
/**
 * Checks if anvil exists
 *
 * @return true if `anvil` exists
 */
async function checkAnvil() {
    return checkCommand("anvil --version");
}
exports.checkAnvil = checkAnvil;
/**
 * Checks if cast exists
 *
 * @return true if `cast` exists
 */
async function checkCast() {
    return checkCommand("cast --version");
}
exports.checkCast = checkCast;
/**
 * Checks if cast exists
 *
 * @return true if `cast` exists
 */
async function checkForge() {
    return checkCommand("forge --version");
}
exports.checkForge = checkForge;
/**
 * Executes the given command
 *
 * @param cmd the command to run
 * @return returns true if the command succeeded, false otherwise
 */
async function checkCommand(cmd) {
    return new Promise((resolve) => {
        const process = (0, child_process_1.exec)(cmd);
        process.on("exit", (code) => {
            if (code !== 0) {
                console.error("Command failed. Is Foundry not installed? Consider installing via `curl -L https://foundry.paradigm.xyz | bash` and then running `foundryup` on a new terminal. For more context, check the installation instructions in the book: https://book.getfoundry.sh/getting-started/installation.html.");
            }
            resolve(code === 0);
        });
    });
}
/**
 * Executes the given command
 *
 * @param cmd the command to run
 * @return returns true if the command succeeded, false otherwise
 */
function checkCommandSync(cmd) {
    try {
        (0, child_process_1.execSync)(cmd);
        return true;
    }
    catch (error) {
        const status = error.status === 0;
        if (!status) {
            console.error("Command failed. Is Foundry not installed? Consider installing via `curl -L https://foundry.paradigm.xyz | bash` and then running `foundryup` on a new terminal. For more context, check the installation instructions in the book: https://book.getfoundry.sh/getting-started/installation.html.");
        }
        return status;
    }
}
//# sourceMappingURL=binary.js.map